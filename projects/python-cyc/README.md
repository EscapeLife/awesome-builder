# Python-CYC

> **一个完成的编译流程，其实需要我们做很多事情！**

![Python-CYC](../../images/projects/linux-python-cyc.jpg)

如果你曾经写过或者用过 `Python` 代码的话，肯定习惯了创建和编写源代码文件，即以 `.py` 结尾的文件。但是，如果我们的服务或工具需要对外发布或部署的话，那么就需要对源代码进行保护，这样可以最大程度上的保护我们的代码和公司的商业机密不被泄露，也可以防止黑客发现我们程序当中的 `Bug` 来谋取暴利。

这时，我们就需要对 `Python` 源代码文件进行编译了。常见的，我们会将其编译为 `.so` 结尾的二进制文件，但是有些文件编译之后会导致服务无法启动或功能无法使用，这时则会那些无法编译成 `.so` 文件的编译为 `.pyc` 文件。同时，还需要对 `.sh` 的部署脚本文件进行编译为二进制的可以执行文件。

- `.py` -> `.so`
- `.py` -> `.pyc`
- `.sh` -> `bin`

我们项目当中的 `cyc.sh` 脚本就是将其编译为上述所需的密码文件，但是在使用过程中需要我们根据项目的实际情况进行调整和适配。

```bash
# 使用方式
./projects/python-cyc/cyc.sh
```

在考虑完成编译加密的问题之后，接着需要考虑到的就是，性能问题！比如，我们有三台机器，上面都部署有 `ci` 自动构建服务，两个配置都比较低，一台配置高。如果我们在打包镜像的时候，各使用各的话，就会会存在低配置的机器在执行 `cyc` 步骤的时候特别慢(主要是和 `CPU` 核数呈正相关)。所以，我们可以在配置高的机器上面部署一个服务，专职负责编译文件。

```bash
# 构建打包CYC的服务镜像
docker build --build-arg --squash --no-cache --tag=cyc_server:latest .

# 运行CYC服务镜像
docker run --name cyc_server -d -p 8000:8000 cyc_server:latest
```
